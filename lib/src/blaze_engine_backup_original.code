import 'dart:io';
import 'dart:async';

class BlazeDownloader {
  final String downloadUrl;
  final String customDirectory;
  final bool segmentedDownload;
  BlazeDownloader({
    this.segmentedDownload = false,
    required this.downloadUrl,
    required this.customDirectory,
  });

  Future<void> startDownload() async {
    final fileName = _getFileNameFromUrl(downloadUrl);
    final filePath = await _createFile(fileName);

    try {
      final totalSize = await _getFileSizeFromUrl(downloadUrl);
      if (totalSize == 0) {
        print('Could not retrieve file size. Aborting download.');
        return;
      }

      final canResume = await _supportsRangeRequests(downloadUrl);

      if (canResume) {
        await _downloadFile(filePath, totalSize);
      } else {
        print(
            'Resume capability not supported, downloading the entire file...');
        await _downloadFile(filePath, totalSize, allowResume: false);
      }
    } catch (e) {
      print('Error during download: $e');
    }
  }

  Future<String> _createFile(String fileName) async {
    final directory = Directory(customDirectory);

    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }

    return '${directory.path}/$fileName';
  }

  Future<int> _getFileSizeFromPath(String filePath) async {
    try {
      final file = File(filePath);
      if (await file.exists()) {
        final fileStat = await file.stat();
        return fileStat.size;
      } else {
        print('File does not exist: $filePath');
      }
    } catch (e) {
      print('Error while getting file size: $e');
    }
    return 0;
  }

  Future<int> _getFileSizeFromUrl(String url) async {
    try {
      final request = await HttpClient().headUrl(Uri.parse(url));
      final response = await request.close();

      if (response.statusCode == 200) {
        final contentLength = response.headers.value('content-length');
        if (contentLength != null) {
          return int.parse(contentLength);
        }
      } else {
        print(
            'Failed to get file size with status code: ${response.statusCode}');
      }
    } catch (e) {
      print('Error while getting file size: $e');
    }
    return 0;
  }

  Future<void> _downloadFile(String filePath, int totalSize,
      {bool allowResume = true}) async {
    final file = File(filePath);
    int startByte = 0;

    if (allowResume && await file.exists()) {
      startByte = await _getFileSizeFromPath(filePath);
      if (startByte >= totalSize) {
        print('File already downloaded: $filePath');
        return;
      }
      print('Resuming download from byte: $startByte');
    } else {
      print('Starting new download...');
    }

    final request = await HttpClient().getUrl(Uri.parse(downloadUrl));

    final endByte = totalSize - 1;
    request.headers.add('Range', 'bytes=$startByte-$endByte');

    final response = await request.close();

    if (response.statusCode == 206) {
      await response.pipe(file.openWrite(mode: FileMode.append));
      await _checkFileIntegrity(filePath, totalSize);
    } else if (response.statusCode == 200) {
      print(
          'Server does not support range requests. Downloading the entire file...');
      await response.pipe(file.openWrite());
      await _checkFileIntegrity(filePath, totalSize);
    } else {
      print('Download failed with status code: ${response.statusCode}');
    }
  }

  Future<void> _checkFileIntegrity(String filePath, int expectedSize) async {
    final downloadedSize = await _getFileSizeFromPath(filePath);
    if (expectedSize == downloadedSize) {
      print('Download completed: $filePath');
    } else {
      print(
          'File corrupted: Expected size $expectedSize, but got $downloadedSize');
    }
  }

  Future<bool> _supportsRangeRequests(String url) async {
    try {
      final request = await HttpClient().headUrl(Uri.parse(url));
      final response = await request.close();

      if (response.statusCode == 200) {
        final acceptRanges = response.headers.value('Accept-Ranges');
        if (acceptRanges == 'bytes') {
          print('Server supports resume capability.');
          return true;
        } else {
          print('Server does not support resume capability.');
        }
      } else {
        print(
            'Failed to check resume capability with status code: ${response.statusCode}');
      }
    } catch (e) {
      print('Error while checking resume capability: $e');
    }
    return false;
  }

  String _getFileNameFromUrl(String url) {
    return url.split('/').last;
  }
}
