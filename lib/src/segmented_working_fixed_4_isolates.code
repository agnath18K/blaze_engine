import 'dart:io';
import 'dart:async';
import 'dart:isolate';

class BlazeDownloader {
  final String downloadUrl;
  final String customDirectory;
  final int segmentCount;

  BlazeDownloader({
    required this.downloadUrl,
    required this.customDirectory,
    this.segmentCount = 20, // Default to 4 segments
  });

  Future<void> startDownload() async {
    final fileName = _getFileNameFromUrl(downloadUrl);
    final filePath = await _createFile(fileName);

    try {
      final totalSize = await _getFileSizeFromUrl(downloadUrl);
      if (totalSize == 0) {
        print('Could not retrieve file size. Aborting download.');
        return;
      }

      await _downloadFile(fileName, filePath, totalSize);
    } catch (e) {
      print('Error during download: $e');
    }
  }

  Future<String> _createFile(String fileName) async {
    final directory = Directory(customDirectory);

    // Ensure the directory exists
    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }

    return '${directory.path}/$fileName';
  }

  Future<int> _getFileSizeFromPath(String filePath) async {
    try {
      final file = File(filePath);
      if (await file.exists()) {
        final fileStat = await file.stat();
        return fileStat.size; // Returns the size in bytes
      } else {
        print('File does not exist: $filePath');
      }
    } catch (e) {
      print('Error while getting file size: $e');
    }
    return 0; // Return 0 if failed
  }

  Future<int> _getFileSizeFromUrl(String url) async {
    try {
      final request = await HttpClient().headUrl(Uri.parse(url));
      final response = await request.close();

      if (response.statusCode == 200) {
        final contentLength = response.headers.value('content-length');
        if (contentLength != null) {
          return int.parse(contentLength);
        }
      } else {
        print(
            'Failed to get file size with status code: ${response.statusCode}');
      }
    } catch (e) {
      print('Error while getting file size: $e');
    }
    return 0; // Return 0 if failed
  }

  Future<void> _downloadFile(
      String fileName, String filePath, int totalSize) async {
    final segmentSize =
        (totalSize / segmentCount).ceil(); // Divide into specified segments
    List<ReceivePort> ports = [];
    List<String> segmentFiles =
        []; // List to hold paths of downloaded segment files
    bool downloadFailed = false;

    // Create and spawn isolates for downloading segments
    for (int i = 0; i < segmentCount; i++) {
      final startByte = i * segmentSize;
      final endByte = (i == segmentCount - 1)
          ? totalSize - 1
          : startByte + segmentSize - 1; // last segment takes remaining bytes

      final port = ReceivePort();
      ports.add(port);

      // Create a temporary file for each segment
      final segmentFile = await _createFile('${fileName}_part$i');
      segmentFiles.add(segmentFile);

      // Spawn an isolate for downloading each segment
      await Isolate.spawn(_downloadSegment,
          [port.sendPort, downloadUrl, segmentFile, startByte, endByte]);

      print('Downloading segment:');
      print('URL: $downloadUrl');
      print('Segment file path: $segmentFile');
      print('Start byte: $startByte');
      print('End byte: $endByte');
    }

    // Wait for all segments to be downloaded
    for (var port in ports) {
      final result = await port.first;
      if (result is String && result.startsWith('Error')) {
        downloadFailed = true;
      }
    }

    if (downloadFailed) {
      print('Download failed, cleaning up segment files.');
      await _cleanupSegmentFiles(segmentFiles);
      return;
    }

    // Merge the downloaded segments into a single output file
    await _mergeFileSegments(segmentFiles, filePath);

    // Check integrity of the merged file
    await _checkFileIntegrity(filePath, totalSize);

    // Cleanup segment files after successful merge
    await _cleanupSegmentFiles(segmentFiles);
  }

  static Future<void> _downloadSegment(List<dynamic> args) async {
    final SendPort sendPort = args[0];
    final String url = args[1];
    final String segmentFilePath = args[2];
    final int startByte = args[3];
    final int endByte = args[4];

    try {
      final request = await HttpClient().getUrl(Uri.parse(url));
      request.headers.add('Range', 'bytes=$startByte-$endByte');

      final response = await request.close();

      if (response.statusCode == 206 || response.statusCode == 200) {
        final file = File(segmentFilePath);

        // Write the received bytes to the segment file
        await response.pipe(file.openWrite());

        // Notify the main isolate that this segment has been downloaded
        sendPort.send('Segment $startByte-$endByte downloaded successfully.');
      } else {
        sendPort.send(
            'Download failed with status code: ${response.statusCode} for segment $startByte-$endByte');
      }
    } catch (e) {
      print('Error downloading segment: $e');
      sendPort.send('Error downloading segment $startByte-$endByte: $e');
    }
  }

  Future<void> _checkFileIntegrity(String filePath, int expectedSize) async {
    final downloadedSize = await _getFileSizeFromPath(filePath);
    if (expectedSize == downloadedSize) {
      print('Download completed: $filePath');
    } else {
      print(
          'File corrupted: Expected size $expectedSize, but got $downloadedSize');
    }
  }

  Future<void> _mergeFileSegments(
      List<String> segmentFiles, String outputFilePath) async {
    final outputFile = File(outputFilePath);
    final sink = outputFile.openWrite();

    try {
      for (String segmentFile in segmentFiles) {
        final segment = File(segmentFile);

        // Check if segment file exists and is not empty
        if (!await segment.exists()) {
          print('Segment file does not exist: $segmentFile');
          return; // Handle as needed
        }

        final segmentStat = await segment.stat();
        if (segmentStat.size == 0) {
          print('Segment file is empty: $segmentFile');
          return; // Handle as needed
        }

        // Read from the segment file and write to the output file
        await for (var data in segment.openRead()) {
          await sink.addStream(Stream.value(data));
        }
      }
      print('Merged file created at: ${outputFile.path}');
    } catch (e) {
      print('Error merging file segments: $e');
    } finally {
      // Ensure the sink is closed only once after merging all segments
      await sink.close();
    }
  }

  Future<void> _cleanupSegmentFiles(List<String> segmentFiles) async {
    for (var segmentFile in segmentFiles) {
      try {
        final file = File(segmentFile);
        if (await file.exists()) {
          await file.delete();
          print('Deleted segment file: $segmentFile');
        }
      } catch (e) {
        print('Error deleting segment file $segmentFile: $e');
      }
    }
  }

  String _getFileNameFromUrl(String url) {
    return url.split('/').last;
  }
}
